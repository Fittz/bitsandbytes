#- this class executes freefem++ programs to generate meshes.The meshes are then used to create an slf file which is analysed for structural weaknesses
#create_mesh(program,saveMesh): This executes a given freefem program and generates a .mesh file, if saveRun is true it will save the mesh to a unique filename
#parse_mesh(): read .mesh file into nodes,triangles and edges and add them to the mesh lists
#build_lists(): break triangles into separate edges, find fixed nodes and build a list of load bearing beams
#create_slf_file(): uses the lists to outputa file formatted for slffea
#test_slf_file(): runs slffea
#show_analysis(); opens the slffea gui and graphs the stresses
#parse_results(): reads results from slffea output and builds a stressList
#calculate_stresses(stressList): find average stress and no. of failed beams
#print_stresses(): print the stats for the mesh
#test_mesh():
#show_mesh():

import subprocess,re,os
#this class will create the meshes and analyise them
class Mesh():
    counter=1
    broken=0
    def __init__(self,program,saveRun=False):
        self.name = 'test'
        #stores all the slffea values
        self.material ={}
        self.program=program
        self.saveRun=saveRun
        self.totalZLoad=1000000
        self.avrZLoad=0
        self.totalYLoad=1000
        self.avrYLoad=0
        self.edgeList=[]
        self.triList=[]
        self.nodeList=[]
        self.fixedList=[]
        self.loadNodes=[]
        self.loadElems=[]
        self.max = {'x':0,'y':0,'z':0}
        self.min = {'x':0,'y':0,'z':0}
        self.XXStress = {'totalTens':1,'totalComp':1,'avrTens':0,'avrComp':0,'maxTens':0,'maxComp':0,'beamTens':1,'beamComp':1,'failTens':0,'failComp':0}
        self.XYStress = {'totalTens':1,'totalComp':1,'avrTens':0,'avrComp':0,'maxTens':0,'maxComp':0,'beamTens':1,'beamComp':1,'failTens':0,'failComp':0}
        self.ZXStress = {'totalTens':1,'totalComp':1,'avrTens':0,'avrComp':0,'maxTens':0,'maxComp':0,'beamTens':1,'beamComp':1,'failTens':0,'failComp':0}

    def set_material(self, **kwargs):
        input = kwargs
        self.material['width'] = 100
        self.material['height'] = 200
        self.material['emod'] = 10000000000
        self.material['density'] = 5300
        self.material['area'] = (float(self.material['width']))*(float(self.material['height']))*10.0**(-6)
        self.material['iz'] = (((float(self.material['width']))*(float(self.material['height'])**3))/12)*10**(-12)
        self.material['iy'] = (((float(self.material['height']))*(float(self.material['width'])**3))/12)*10**(-12)
        self.material['allowedXXTension'] = (1.8*10**7)
        self.material['allowedXXCompression'] = (2.3*10**7)
        self.material['allowedXYTension'] = (0.6*10**6)
        self.material['allowedXYCompression'] = (8.4*10**6)
        self.material['allowedZXTension'] = self.material['allowedXYTension']
        self.material['allowedZXCompression'] = self.material['allowedXYCompression']
        self.material['maxmoment'] = (3*10**7)
        
    def create_mesh(self,save = False,filename='1'):
        opFile = open(self.name+'.edp','w')
        if self.saveRun:
            #print "saving eps"
            #opFile.write(self.program+"plot(test2d,wait=1,ps=\""+str(Mesh.counter)+".eps\");")
            opFile.write(self.program+"savemesh(test,\"xxx."+str(Mesh.counter)+".mesh\");")
            Mesh.counter += 1
        elif save:
            opFile.write(self.program+"savemesh(test,\""+filename+".mesh\");")
        else:
            opFile.write(self.program)
        opFile.close()
        if os.path.isfile(self.name+'.mesh'):
            os.remove(self.name+'.mesh')
        cmd = "fem "+self.name+'.edp'+' -nw'
        process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE)
        process.communicate()

    #reads .mesh files generated by tetgen
    def parse_mesh(self):
        threeD = False
        # getting no. of elements from file header
        meshFile = open(self.name+'.mesh','r')
        lines = iter(meshFile)
        for line in lines:
            if line.strip() == 'Dimension 3':
                threeD = True
            #extract nodes
            if line.strip() == 'Vertices':
                line = lines.next()
                nodes = int(line)
                for i in range(nodes):
                    line = lines.next()
                    nodeString = line.strip()
                    regex = "[+-]?\d+[\.\d|\.e\-\d]*"
                    match = re.findall(regex, nodeString)
                    if threeD:
                        x,y,z = float(match[0]),float(match[1]),float(match[2])
                    else:
                        x,y,z = float(match[0]),float(match[1]),0
                    # find the coords to create fixed and load points
                    if x > self.max['x']:
                        self.max['x'] = x
                    elif x < self.min['x']:
                        self.min['x'] = x
                    if y > self.max['y']:
                        self.max['y'] = y
                    elif y < self.min['y']:
                        self.min['y'] = y
                    if z > self.max['z']:
                        self.max['z'] = z
                    elif z < self.min['z']:
                        self.min['z'] = z
                    node = {'id':str(i),'x':str(x),'y':str(y),'z':str(z)}
                    self.nodeList.append(node)
            #extract triangles
            if line.strip() == 'Triangles':
                line = lines.next()
                triangles = int(line)
                for i in range(triangles):
                    line = lines.next()
                    triString = line.strip()
                    regex = "\d+"
                    match = re.findall(regex, triString) 
                    #slffea freaks out it the index does not start at 0
                    a,b,c = int(match[0])-1,int(match[1])-1,int(match[2])-1 
                    triangle = {'id':str(i),'ptA':str(a),'ptB':str(b),'ptC':str(c)}
                    self.triList.append(triangle)

            #extract edges
            if line.strip() == 'Edges':
                line = lines.next()
                edges = int(line)
                for i in range(edges):
                    line = lines.next()
                    edgeString = line.strip()
                    regex = "\d+"
                    match = re.findall(regex, edgeString) 
                    a,b = int(match[0])-1,int(match[1])-1
                    edge = {'id':str(i),'ptA':str(a),'ptB':str(b)}
                    self.edgeList.append(edge)
        meshFile.close()
        self.build_lists()

    def build_lists(self):
        #print "no of triangles: ", len(self.triList)
        #turn triangles into edges
        for tri in self.triList:
            edge1 = [tri['ptA'],tri['ptB']]
            edge2 = [tri['ptB'],tri['ptC']]
            edge3 = [tri['ptC'],tri['ptA']]
            newEdge1 = True
            newEdge2 = True
            newEdge3 = True
            for edge in self.edgeList:
                if newEdge1 and edge['ptA'] in edge1 and edge['ptB'] in edge1:
                    newEdge1 = False
                if newEdge2 and edge['ptA'] in edge2 and edge['ptB'] in edge2:
                    newEdge2 = False
                if newEdge3 and edge['ptA'] in edge3 and edge['ptB'] in edge3:
                    newEdge3 = False
            if newEdge1:
                newEdge = edge = {'ptA':edge1[0],'ptB':edge1[1]}
                self.edgeList.append(newEdge)
            if newEdge2:
                newEdge = edge = {'ptA':edge2[0],'ptB':edge2[1]}
                self.edgeList.append(newEdge)
            if newEdge3:
                newEdge = edge = {'ptA':edge3[0],'ptB':edge3[1]}
                self.edgeList.append(newEdge)

        # removing any unconnected nodes
        # replace nodeIds in edglist with the node's coordinates
        for edge in self.edgeList:
            for node in self.nodeList:
                if edge['ptA'] == node['id']:
                    edge['ptA'] = node['x'], node['y'], node['z'] 
                if edge['ptB'] == node['id']:
                    edge['ptB'] = node['x'], node['y'], node['z']
        
        # rebuild the nodelist with connected nodes
        self.nodeList = [] 
        for edge in self.edgeList:
            if edge['ptA'] not in self.nodeList:            
                self.nodeList.append(edge['ptA'])
            if edge['ptB'] not in self.nodeList:
                self.nodeList.append(edge['ptB'])

        # replace coords in edgelist with nodeIds
        for index,edge in enumerate(self.edgeList):
            edge['id'] = str(index)
            for i,n in enumerate(self.nodeList):
                if edge['ptA'] == n:
                    edge['ptA'] = i
                if edge['ptB'] == n:
                    edge['ptB'] = i                    
            
        # Re-structure the new nodeList so it can be read by everything else.
        newnodeList = []
        for i, node in enumerate(self.nodeList):
            x,y,z = node[0], node[1], node[2]
            adjustednode = {'id':str(i),'x':str(x),'y':str(y),'z':str(z)}
            newnodeList.append(adjustednode)
        self.nodeList = newnodeList 
        
        #build fixed points list and load list
        for node in self.nodeList:
            axis = 'z'
            if float(node[axis]) == self.min[axis]:
                self.fixedList.append(node)
            if float(node[axis]) == self.max[axis]:
                self.loadNodes.append(node['id'])

        #SLFFEA applies load to edges, find edges connecting loadNodes
        for edge in self.edgeList:
            if str(edge['ptA']) in self.loadNodes and str(edge['ptB']) in self.loadNodes:
                self.loadElems.append(edge)
        self.avrZLoad = self.totalZLoad/len(self.loadElems)
        self.avrYLoad = self.totalYLoad/len(self.loadElems)
        
    def create_slf_file(self):
        mesh= open(self.name,'w')
        mesh.write('numel numnp nmat nmode (This is for a beam bridge)\n')
        mesh.write(str(len(self.edgeList))+' '+str(len(self.nodeList))+' 1 0\n')
        mesh.write('matl no., E mod, Poiss. Ratio,density, Area, Iy, Iz\n')
        mesh.write('0 '+str(self.material['emod'])+' 0.0000 '+str(self.material['density'])+' '+str(self.material['area'])+' '+str(self.material['iy'])+' '+str(self.material['iz']) + '\n')
        mesh.write('el no.,connectivity, matl no, element type\n')
        for i, edge in enumerate(self.edgeList): # this should work no problem (i think), but it gives seg faults all over the shop.
            mesh.write(str(i)+' '+str(edge['ptA'])+' '+str(edge['ptB'])+' 0 2 \n')
        mesh.write('node no., coordinates\n')
        for node in self.nodeList:
            mesh.write(node['id']+' '+node['x']+' '+node['y']+' '+node['z']+"\n")
        mesh.write("element with specified local z axis: x, y, z component\n -10\n")
        mesh.write('prescribed displacement x: node  disp value\n')
        for node in self.fixedList:
            mesh.write(node['id']+" 0.0\n")
        mesh.write('-10\nprescribed displacement y: node  disp value\n')
        for node in self.fixedList:
            mesh.write(node['id']+" 0.0\n")
        mesh.write('-10\nprescribed displacement z: node  disp value\n')
        for node in self.fixedList:
            mesh.write(node['id']+" 0.0\n")
        mesh.write('-10\nprescribed angle phi x: node angle value\n -10')
        mesh.write('\nprescribed angle phi y: node angle value\n -10')
        mesh.write('\nprescribed angle phi z: node angle value\n -10')
        mesh.write('\nnode with point load x, y, z and 3 moments phi x, phi y, phi z\n-10\n')
        mesh.write('element with distributed load in local beam y and z coordinates\n')
        for elem in self.loadElems:
            #mesh.write(elem['id']+' 0 -'+str(self.avrLoad)+' \n') 
            mesh.write(elem['id']+' -'+str(self.avrYLoad)+' -'+str(self.avrZLoad)+' \n') 
        mesh.write('-10\nelement no. and gauss pt. no. with local stress vector xx and moment xx,yy,zz\n-10')
        mesh.close()

    def test_slf_file(self):
        #run the structural analysis software
        cmd = 'bm'
        process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE)
        process.communicate(self.name)

    def show_analysis(self):
        cmd = "echo "+self.name+'.obm | bmpost'
        process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE)

    def parse_results(self):
        stressHeader1 = "element no. and nodal pt. no. with local stress xx,xy,zx and moment xx,yy,zz"
        stressHeader2 = "element no. and gauss pt. no. with local stress xx,xy,zx and moment xx,yy,zz"
        stressList = []
        results = open(self.name+'.obm','r')  # opens the results file
        lines = iter(results)
        for line in lines:
            if line.startswith(stressHeader1) or line.startswith(stressHeader2): 
                line = lines.next()
                while  line.strip() != ('-10'):		
                    result = line.split()
                    # check if its busted
                    if 'nan' in result or '-nan' in result:
                        print "**************STRUCTURE FAILED****************"
                        xxFloat,xyFloat,zxFloat= defaultFitness, defaultFitness,defaultFitness
                        xx,xy,zx = int(xxFloat),int(xyFloat),int(zxFloat)
                        stress = {'xx':xx,'xy':xy,'zx':zx}
                        stressList.append(stress)
                        if saveBroken:
                            filename = 'broke.'+str(Mesh.broken)
                            self.create_mesh(True,filename)
                            Mesh.broken +=1
                        break
                    else:  
                        xxFloat,xyFloat,zxFloat = float(result[2]),float(result[3]),float(result[4])
                        xx,xy,zx = int(xxFloat),int(xyFloat),int(zxFloat)
                        stress = {'xx':xx,'xy':xy,'zx':zx}
                        stressList.append(stress)
                        line = lines.next()
        results.close()
        self.calculate_stresses(stressList)
    
    def calculate_stresses(self,stressList):
        for stress in stressList:
            xx,xy,zx = stress['xx'],stress['xy'],stress['zx']
            #calculate stresses on XX plane
            df = defaultFitness
            if xx == df or xy == df or zx == df:
                self.XXStress = {'totalTens':df,'totalComp':df,'maxTens':df,'maxComp':df,'beamTens':1,'beamComp':1,'failTens':df,'failComp':df}
                self.XYStress = {'totalTens':df,'totalComp':df,'maxTens':df,'maxComp':df,'beamTens':1,'beamComp':1,'failTens':df,'failComp':df}
                self.ZXStress = {'totalTens':df,'totalComp':df,'maxTens':df,'maxComp':df,'beamTens':1,'beamComp':1,'failTens':df,'failComp':df}
            if xx > 0:
                self.XXStress['totalTens'] += xx
                self.XXStress['beamTens'] +=1
                if self.XXStress['maxTens'] < xx:
                    self.XXStress['maxTens'] = xx 
                if xx > self.material['allowedXXTension']:
                    self.XXStress['failTens'] +=1
            else:
                xx = abs(xx)
                self.XXStress['totalComp'] += xx
                self.XXStress['beamComp'] += 1
                if self.XXStress['maxComp'] < xx:
                    self.XXStress['maxComp'] = xx
                if xx > self.material['allowedXXCompression']:
                    self.XXStress['failComp'] +=1

            #calculate stresses on XY plane
            if xy > 0:
                self.XYStress['totalTens'] += xy
                self.XYStress['beamTens'] +=1
                if self.XYStress['maxTens'] < xy:
                    self.XYStress['maxTens'] = xy 
                if xy > self.material['allowedXYTension']:
                    self.XYStress['failTens'] +=1
            else:
                xy = abs(xy)
                self.XYStress['totalComp'] += xy
                self.XYStress['beamComp'] += 1
                if self.XYStress['maxComp'] < xy:
                    self.XYStress['maxComp'] = xy
                if xy > self.material['allowedXYCompression']:
                    self.XYStress['failComp'] +=1

            #calculate stresses on ZX plane        
            if zx > 0:
                self.ZXStress['totalTens'] += zx
                self.ZXStress['beamTens'] +=1
                if self.ZXStress['maxTens'] < zx:
                    self.ZXStress['maxTens'] = zx 
                if zx > self.material['allowedZXTension']:
                    self.ZXStress['failTens'] +=1
            else:
                zx = abs(zx)
                self.ZXStress['totalComp'] += zx
                self.ZXStress['beamComp'] += 1
                if self.ZXStress['maxComp'] < zx:
                    self.ZXStress['maxComp'] = zx
                if zx > self.material['allowedZXCompression']:
                    self.ZXStress['failComp'] +=1
        #handy for debugging
        #self.print_stresses()
                    

        self.XXStress['avrTens'] = self.XXStress['totalTens'] / self.XXStress['beamTens'] 
        self.XYStress['avrTens'] = self.XYStress['totalTens'] / self.XYStress['beamTens'] 
        self.ZXStress['avrTens'] = self.ZXStress['totalTens'] / self.ZXStress['beamTens']  
        self.XXStress['avrComp'] = self.XXStress['totalComp'] / self.XXStress['beamComp'] 
        self.XYStress['avrComp'] = self.XYStress['totalComp'] / self.XYStress['beamComp'] 
        self.ZXStress['avrComp'] = self.ZXStress['totalComp'] / self.ZXStress['beamComp'] 

    def print_stresses(self):
        print "XX Stress: ",str(self.XXStress)
        print "XY Stress: ",str(self.XYStress)
        print "ZX Stress: ",str(self.ZXStress)

    def test_mesh(self):
        self.create_mesh()
        self.parse_mesh()
        self.create_slf_file()
        self.test_slf_file()
        self.parse_results()

    def show_mesh(self):
        self.create_mesh()
        self.parse_mesh()
        self.create_slf_file()
        self.test_slf_file()
        self.parse_results()
        print "load bearing nodes:"
        print str(self.loadNodes)
        self.print_stresses()
        self.show_analysis()

# global class variables
saveBroken = False
defaultFitness = 1000000

